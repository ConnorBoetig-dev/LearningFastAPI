# =============================================================================================
# APP/MODELS/USER.PY - USER DATABASE MODEL
# =============================================================================================
# This module defines the User table schema using SQLAlchemy ORM.
#
# WHAT IS AN ORM MODEL?
# - Object-Relational Mapping: Python class ↔ Database table
# - Each class attribute → table column
# - Each instance → table row
# - SQLAlchemy auto-generates SQL (INSERT, SELECT, UPDATE, DELETE)
#
# USER TABLE SCHEMA:
# - id: UUID stored as string (auto-generated by Python uuid4)
# - email: Unique email address (used for login)
# - password_hash: Bcrypt-hashed password (never store plaintext!)
# - created_at: Timestamp when account was created
#
# SECURITY NOTES:
# - Email is unique (enforced at database level)
# - Password is hashed before storage (see security.py)
# - UUID prevents enumeration attacks (can't guess user IDs like 1, 2, 3...)
# =============================================================================================

from datetime import datetime, timezone
from uuid import uuid4

from sqlalchemy import Column, String, DateTime, Index
from sqlalchemy.orm import relationship

from app.core.db import Base


# -------------------------
# User model - Maps to "users" table
# -------------------------
class User(Base):
    """
    User account model for authentication and authorization.

    DATABASE TABLE (SQLite):
        CREATE TABLE users (
            id VARCHAR(36) PRIMARY KEY,
            email VARCHAR(255) UNIQUE NOT NULL,
            password_hash VARCHAR(60) NOT NULL,
            created_at TIMESTAMP NOT NULL
        );
        CREATE UNIQUE INDEX ix_users_email ON users (email);

    COLUMNS EXPLAINED:
    - id: Universally Unique Identifier stored as string
      * Generated by Python using uuid.uuid4()
      * Format: "123e4567-e89b-12d3-a456-426614174000" (36 chars with hyphens)
      * Why UUID vs integer? Prevents enumeration, better for distributed systems
      * SQLite doesn't have native UUID type, so we use VARCHAR(36)
    - email: User's email address (used for login)
      * Unique constraint prevents duplicate accounts
      * Indexed for fast lookups during login
    - password_hash: Bcrypt hash of user's password
      * 60 characters: $2b$12$... (algorithm + rounds + salt + hash)
      * Never store plaintext passwords!
    - created_at: Account creation timestamp
      * UTC timezone (consistent across servers)
      * Useful for analytics, compliance (GDPR data retention), etc.

    RELATIONSHIPS:
    - refresh_tokens: One user can have multiple refresh tokens (different devices/sessions)

    USAGE EXAMPLES:
        # Create new user
        user = User(email="alice@example.com", password_hash=hashed_password)
        db.add(user)
        db.commit()
        db.refresh(user)  # Load auto-generated id and created_at

        # Find user by email
        user = db.query(User).filter(User.email == "alice@example.com").first()

        # Check if email exists
        exists = db.query(User.id).filter(User.email == "test@example.com").first() is not None
    """

    # -------------------------
    # Table name in SQLite database
    # -------------------------
    __tablename__ = "users"

    # -------------------------
    # COLUMN 1: Primary key (UUID as string)
    # -------------------------
    # String(36) stores UUID in format: "123e4567-e89b-12d3-a456-426614174000"
    # - 36 characters including hyphens
    # - Generated by Python's uuid.uuid4() function
    # - SQLite doesn't have native UUID type, so we use VARCHAR
    #
    # default=lambda: str(uuid4()):
    # - Auto-generate UUID when INSERT doesn't provide one
    # - Generated in Python (not database)
    # - uuid4() returns UUID object, str() converts to string format
    id: str = Column(
        String(36),              # VARCHAR(36) - stores UUID with hyphens
        primary_key=True,        # Unique identifier for each row
        default=lambda: str(uuid4()),  # Auto-generate UUID in Python
        nullable=False,          # Must always have a value
        comment="User's unique identifier (UUID v4 as string)",
    )

    # -------------------------
    # COLUMN 2: Email address (unique, indexed)
    # -------------------------
    # String(255) = VARCHAR(255) in SQL
    # unique=True creates a UNIQUE constraint (prevents duplicate emails)
    # index=True creates an index for fast lookups (speeds up login queries)
    #
    # WHY UNIQUE EMAIL?
    # - Prevents multiple accounts with same email
    # - Email is the username for login
    # - Unique constraint enforced at database level (prevents race conditions)
    #
    # WHY INDEX?
    # - Login queries: SELECT * FROM users WHERE email = ?
    # - Without index: Full table scan (slow for millions of users)
    # - With index: Binary search in B-tree (logarithmic time)
    email: str = Column(
        String(255),       # Max length 255 characters (standard email limit)
        unique=True,       # No duplicate emails allowed
        nullable=False,    # Email is required
        index=True,        # Create index for fast lookups
        comment="User's email address (used for login, must be unique)",
    )

    # -------------------------
    # COLUMN 3: Password hash (bcrypt)
    # -------------------------
    # String(60) because bcrypt hashes are always 60 characters:
    #   $2b$12$abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ
    #   └┬─┘└┬┘ └──────────────┬──────────────┘└──────┬──────┘
    #    │   │                 │                       └─ Hash (31 bytes)
    #    │   │                 └─ Salt (22 bytes)
    #    │   └─ Cost factor (2^12 = 4096 rounds)
    #    └─ Algorithm (2b = bcrypt version)
    #
    # WHY NEVER STORE PLAINTEXT?
    # - Database breach → attacker gets all passwords
    # - Insiders (DBAs) can see passwords
    # - Passwords often reused across sites (compromise spreads)
    # - Bcrypt hash is one-way (can't reverse to get password)
    password_hash: str = Column(
        String(60),        # Bcrypt hashes are exactly 60 chars
        nullable=False,    # Password is required
        comment="Bcrypt hash of user's password (never store plaintext!)",
    )

    # -------------------------
    # COLUMN 4: Account creation timestamp
    # -------------------------
    # DateTime stores timestamp in SQLite
    # SQLite doesn't have native TIMESTAMP type, stores as TEXT/INTEGER/REAL
    # default= sets value in Python (when object is created)
    # This is a *Python* default, not a database default
    #
    # WHY UTC?
    # - Consistent across time zones (server might be in different region than users)
    # - Daylight saving doesn't affect it
    # - Easy to convert to user's local time in frontend
    #
    # NOTE: SQLite stores datetime as ISO 8601 string: "2024-01-15 10:30:00.123456"
    created_at: datetime = Column(
        DateTime,                # SQLite stores as TEXT in ISO 8601 format
        default=lambda: datetime.now(timezone.utc),  # Set to current UTC time
        nullable=False,           # Must always have a value
        comment="When this account was created (UTC timezone)",
    )

    # -------------------------
    # Relationships (ORM navigation)
    # -------------------------
    # One-to-many relationship: User has many RefreshTokens
    # Allows navigating from User to their tokens:
    #   user.refresh_tokens → list of RefreshToken objects
    #
    # back_populates="user" creates bidirectional relationship:
    # - From User: user.refresh_tokens (list)
    # - From RefreshToken: token.user (single User object)
    #
    # lazy="select" (default) loads tokens on first access (prevents N+1 queries)
    # cascade="all, delete-orphan" ensures:
    # - If user is deleted → all their tokens are deleted
    # - If token is removed from user.refresh_tokens list → it's deleted from DB
    refresh_tokens = relationship(
        "RefreshToken",  # Model name (as string to avoid circular import)
        back_populates="user",  # Field name in RefreshToken model
        lazy="select",  # Load on access, not automatically
        cascade="all, delete-orphan",  # Delete tokens when user is deleted
    )

    # -------------------------
    # Indexes (for query performance)
    # -------------------------
    # Already created index on email via index=True above
    # Add more indexes here if needed:
    # __table_args__ = (
    #     Index("ix_users_created_at", "created_at"),  # For sorting by signup date
    # )

    # -------------------------
    # String representation (for debugging)
    # -------------------------
    def __repr__(self) -> str:
        """
        Return a readable string representation of the User object.

        USAGE:
            user = User(email="test@example.com", ...)
            print(user)  # Output: <User(id=UUID('...'), email='test@example.com')>

        DEBUGGING:
            In Python shell or logs, you can see user details without accessing attributes
        """
        return f"<User(id={self.id}, email='{self.email}')>"


# -------------------------
# TODO: Future enhancements
# -------------------------
# Add these fields when needed:
# - is_active: bool (for account suspension)
# - email_verified: bool (for email verification flow)
# - email_verified_at: datetime (when user clicked verification link)
# - is_admin: bool (for role-based access control)
# - last_login_at: datetime (for security monitoring)
# - password_changed_at: datetime (force re-login after password change)
# - two_factor_enabled: bool (for 2FA/MFA support)
# - two_factor_secret: str (TOTP secret for Google Authenticator)
